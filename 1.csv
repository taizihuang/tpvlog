,n,title
0,4,Java多线程基础（一）—— 线程与锁
1,5,Java多线程基础（二）—— Java内存模型
2,6,Java多线程基础（三）—— Single Threaded Execution模式
3,7,Java多线程基础（四）—— Immutable模式
4,8,Java多线程基础（五）—— Guarded Suspension模式
5,9,Java多线程基础（六）—— Balking模式
6,10,Java多线程基础（七）——Producer-Consumer模式
7,11,Java多线程基础（八）—— Read-Write Lock模式
8,12,Java多线程基础（九）—— Thread-Per-Message模式
9,13,Java多线程基础（十）—— Work Thread模式
10,14,Java多线程基础（十一）—— Future模式
11,15,Java多线程基础（十二）—— Two-phase Termination模式
12,16,Java多线程基础（十三）——  Thread-Specific Storage（ThreadLocal）模式
13,17,透彻理解Java并发编程系列
14,18,Java多线程进阶（二）—— J.U.C之locks框架：接口
15,19,Java多线程进阶（三）—— J.U.C之locks框架：ReentrantLock
16,20,Java多线程进阶（四）—— J.U.C之locks框架：ReentrantReadWriteLock
17,21,Java多线程进阶（五）—— J.U.C之locks框架：LockSupport
18,22,Java多线程进阶（六）—— J.U.C之locks框架：AQS综述(1)
19,23,Java多线程进阶（七）—— J.U.C之locks框架：AQS独占功能剖析(2)
20,24,Java多线程进阶（八）—— J.U.C之locks框架：AQS的Conditon等待(3)
21,25,Java多线程进阶（九）—— J.U.C之locks框架：AQS共享功能剖析(4)
22,26,Java多线程进阶（十）—— J.U.C之locks框架：基于AQS的读写锁(5)
23,27,Java多线程进阶（十一）—— J.U.C之locks框架：StampedLock
24,28,Java多线程进阶（十二）——  J.U.C之atomic框架：Unsafe类
25,29,Java多线程进阶（十三）——  J.U.C之atomic框架：AtomicInteger
26,30,Java多线程进阶（十四）——  J.U.C之atomic框架：AtomicReference
27,31,Java多线程进阶（十五）—— J.U.C之atomic框架：Atomic数组
28,32,Java多线程进阶（十六）—— J.U.C之atomic框架：FieldUpdater
29,33,Java多线程进阶（十七）—— J.U.C之atomic框架：LongAdder
30,34,Java多线程进阶（十八）—— J.U.C之synchronizer框架：CountDownLatch
31,35,Java多线程进阶（十九）—— J.U.C之synchronizer框架：CyclicBarrier
32,36,Java多线程进阶（二十）—— J.U.C之synchronizer框架：Semaphore
33,37,Java多线程进阶（二一）—— J.U.C之synchronizer框架：Exchanger
34,38,Java多线程进阶（二二）—— J.U.C之synchronizer框架：Phaser
35,39,Java多线程进阶（二三）—— J.U.C之collections框架：ConcurrentHashMap结构
36,40,Java多线程进阶（二四）—— J.U.C之collections框架：ConcurrentHashMap扩容
37,41,Java多线程进阶（二五）—— J.U.C之collections框架：ConcurrentSkipListMap
38,42,Java多线程进阶（二六）—— J.U.C之collections框架：ConcurrentSkipListSet
39,43,Java多线程进阶（二七）—— J.U.C之collections框架：CopyOnWriteArrayList
40,44,Java多线程进阶（二八）—— J.U.C之collections框架：CopyOnWriteArraySet
41,45,Java多线程进阶（二九）—— J.U.C之collections框架：ConcurrentLinkedQueue
42,46,Java多线程进阶（三十）—— J.U.C之collections框架：ConcurrentLinkedDeque
43,47,Java多线程进阶（三一）—— J.U.C之collections框架：BlockingQueue接口
44,48,Java多线程进阶（三二）—— J.U.C之collections框架：ArrayBlockingQueue
45,49,Java多线程进阶（三三）—— J.U.C之collections框架：LinkedBlockingQueue
46,50,Java多线程进阶（三四）—— J.U.C之collections框架：PriorityBlockingQueue
47,51,Java多线程进阶（三五）—— J.U.C之collections框架：SynchronousQueue
48,52,Java多线程进阶（三六）—— J.U.C之collections框架：DelayQueue
49,53,Java多线程进阶（三七）—— J.U.C之collections框架：LinkedBlockingDeque
50,54,Java多线程进阶（三八）—— J.U.C之collections框架：LinkedTransferQueue
51,55,Java多线程进阶（三九）—— J.U.C之executors框架：executors框架概述
52,56,Java多线程进阶（四十）—— J.U.C之executors框架：ThreadPoolExecutor
53,57,Java多线程进阶（四一）—— J.U.C之executors框架：ScheduledThreadPoolExecutor
54,58,Java多线程进阶（四二）—— J.U.C之executors框架：Future模式
55,60,Java多线程进阶（四三）—— J.U.C之executors框架：Fork/Join框架原理
56,61,Java多线程进阶（四四）—— J.U.C之executors框架：Fork/Join框架实现
57,62,分布式系统从理论到实战系列
58,63,分布式基础（一）—— 分布式理论之分布式一致性：CAP理论
59,64,分布式基础（二）—— 分布式理论之分布式一致性：BASE理论
60,65,分布式基础（四）——分布式理论之分布式一致性：Paxos算法
61,66,分布式基础（五）——分布式理论之分布式一致性：Raft算法原理
62,67,分布式基础（十一）——分布式理论之分布式事务：2PC
63,68,分布式基础（十二）——分布式理论之分布式事务：3PC
64,69,分布式基础（十三）——分布式理论之分布式事务：TCC
65,70,分布式基础（十四）——分布式理论之分布式事务：可靠消息最终一致性方案
66,71,分布式基础（十五）——分布式理论之可扩展：一致性Hash
67,72,分布式基础（十六）——分布式理论之可扩展：Range Based
68,73,分布式基础（十七）——分布式理论之可扩展：全局流水号
69,74,分布式基础（十八）——分布式理论之可扩展：服务化拆分
70,75,分布式基础（十九）——分布式理论之高可用：Master-Slave
71,76,分布式基础（二十）——分布式理论之高可用：集群
72,77,分布式基础（二一）——分布式理论之高可用：降级|熔断|限流
73,78,分布式基础（二二）——分布式理论之高性能：读写分离
74,79,分布式基础（二三）——分布式理论之高性能：分库分表
75,82,分布式基础（二四）——分布式理论之高性能：分布式缓存
76,83,分布式基础（二五）——分布式理论之高性能：负载均衡
77,84,透彻理解JVM系列
78,85,JVM基础（1）——JVM类加载机制
79,86,JVM基础（2）——JVM内存模型
80,87,JVM基础（3）——JVM垃圾回收机制
81,88,JVM基础（4）——JVM存活判定算法
82,89,JVM基础（5）——JVM垃圾回收算法
83,90,JVM基础（6）——JVM垃圾回收器简介
84,91,JVM基础（7）——ParNew垃圾回收器
85,92,JVM基础（8）——CMS垃圾回收器
86,93,JVM基础（9）——新生代调优
87,94,JVM基础（10）——老年代调优
88,95,JVM基础（11）——G1垃圾回收器
89,96,JVM基础（12）——G1调优
90,97,JVM实战（13）——JVM优化概述
91,98,JVM实战（14）——Young GC调优
92,99,JVM实战（15）——Full GC调优
93,100,JVM实战（16）——模拟Young GC
94,101,JVM实战（17）——模拟对象晋升
95,102,JVM实战（18）——模拟Full GC
96,103,JVM实战（19）——JVM调优工具概述
97,104,JVM实战（20）——jstat实战（1）
98,105,JVM实战（21）——jstat实战（2）
99,106,JVM实战（22）——jamp和MAT实战
100,107,JVM实战（23）——内存碎片优化
101,108,JVM实战（24）——大对象优化
102,109,JVM实战（25）——元数据区优化
103,110,JVM实战（26）——SystemGC
104,111,JVM实战（27）——内存溢出概述
105,112,JVM实战（28）——模拟Metaspace内存溢出
106,113,JVM实战（29）——模拟栈内存溢出
107,114,JVM实战（30）——模拟堆内存溢出
108,115,JVM实战（31）——内存溢出之请求超时
109,116,JVM实战（32）——内存溢出之堆外内存
110,117,JVM实战（33）——内存溢出之内存使用率过高
111,118,JVM实战（34）——内存溢出之消息队列处理不当
112,119,分布式进阶（一）——分布式框架之高性能：消息队列
113,120,分布式进阶（二）——分布式框架之高性能：消息队列的可用性
114,121,分布式进阶（三）——分布式框架之高性能：消费的幂等性
115,122,分布式进阶（四）——分布式框架之高性能：消息丢失
116,123,分布式进阶（五）——分布式框架之高性能：消息有序性
117,124,分布式进阶（六）——分布式框架之高性能：消息积压
118,125,透彻理解RocketMQ系列
119,126,分布式消息中间件（一）——概述
120,127,分布式消息中间件（二）——RocketMQ架构
121,128,分布式消息中间件（三）——RocketMQ生产部署
122,129,分布式消息中间件（四）——RocketMQ性能压测
123,130,分布式消息中间件（五）——系统改造：异步、解耦、削峰
124,131,分布式消息中间件（六）——RocketMQ持久化原理
125,132,分布式消息中间件（七）——RocketMQ高可用原理
126,133,分布式消息中间件（八）——RocketMQ消费者原理
127,134,分布式消息中间件（九）——RocketMQ通信原理
128,136,分布式消息中间件（十）——RocketMQ的消息丢失
129,137,分布式消息中间件（十一）——RocketMQ重复消费
130,138,分布式消息中间件（十二）——RocketMQ顺序消息
131,139,分布式消息中间件（十三）——RocketMQ延时消息
132,140,RocketMQ源码分析（一）——RocketMQ源码环境搭建
133,141,RocketMQ源码分析（二）——NameServer启动流程
134,142,RocketMQ源码分析（三）——Broker启动流程
135,143,RocketMQ源码分析（四）——Broker注册原理
136,144,RocketMQ源码分析（五）——Broker心跳原理
137,145,分布式进阶（七）——分布式框架之高性能：分布式搜索引擎
138,146,Elasticsearch基础（一）——概述
139,147,透彻理解Elasticsearch系列
140,148,Elasticsearch基础（二）——开发环境搭建
141,149,Elasticsearch基础（三）——快速上手案例
142,150,Elasticsearch基础（四）——Elasticsearch架构
143,151,Elasticsearch基础（五）——Document并发控制
144,152,Elasticsearch基础（六）——Document路由原理 
145,153,Elasticsearch基础（七）——写一致性原理 
146,154,Elasticsearch基础（八）——持久化原理
147,155,Elasticsearch基础（九）——倒排索引原理 
148,156,Elasticsearch基础（十）——Term Filter
149,157,Elasticsearch基础（十一）——Multi-Field搜索
150,158,Elasticsearch基础（十二）——Proximity Match近似匹配
151,159,Elasticsearch基础（十三）——ngram搜索推荐
152,160,Elasticsearch基础（十四）——相关度分数算法
153,161,Elasticsearch基础（十五）——相关度分数调优
154,162,Elasticsearch基础（十六）——fuzzy模糊搜索
155,163,Elasticsearch基础（十七）——IK中文分词
156,164,Elasticsearch基础（十八）——聚合分析：常用metric操作
157,165,Elasticsearch基础（十九）——聚合分析：histogram区间分组
158,166,Elasticsearch基础（二十）——聚合分析：Aggregation Scope
159,167,Elasticsearch基础（二一）——聚合分析：近似算法
160,168,Elasticsearch基础（二二）——聚合分析：fielddata
161,169,Elasticsearch基础（二三）——聚合分析：遍历算法
162,170,Elasticsearch进阶（一）——生产部署：集群规划
163,171,Elasticsearch进阶（二）——生产部署：集群搭建
164,172,Elasticsearch进阶（三）——生产部署：集群参数配置
165,173,Elasticsearch进阶（四）——生产部署：JVM内存配置
166,174,Elasticsearch进阶（五）——生产部署：OS参数调优
167,175,Elasticsearch进阶（六）——性能调优：慢查询日志
168,176,Elasticsearch进阶（七）——性能调优：基本优化建议
169,177,Elasticsearch进阶（八）——性能调优：读写优化
170,178,分布式进阶（八）——分布式框架之高性能：Elasticsearch架构
171,179,分布式进阶（九）——分布式框架之高性能：ElasticSearch数据持久化
172,180,分布式进阶（十）——分布式框架之高性能：Redis线程模型
173,181,分布式进阶（十一）——分布式框架之高性能：Redis内存管理
174,182,分布式进阶（十二）——分布式框架之高性能：Redis数据持久化
175,183,分布式进阶（十三）——分布式框架之高性能：Redis主从同步
176,184,分布式进阶（十四）——分布式框架之高性能：Redis哨兵模式
177,185,分布式进阶（十五）——分布式框架之高性能：Redis集群模式
178,186,分布式进阶（十六）——分布式框架之高性能：Redis分布式锁
179,187,分布式进阶（十七）——分布式框架之可扩展：Dubbo基本原理
180,189,分布式进阶（十八）——分布式框架之可扩展：Dubbo的SPI机制
181,190,分布式进阶（十九）——分布式框架之可扩展：Spring Cloud
182,191,分布式进阶（二十）——分布式框架之可扩展：Eureka注册中心
183,192,分布式进阶（二一）——分布式框架之可扩展：API网关
184,193,分布式进阶（二二）——分布式框架之可扩展：Zookeeper
185,194,分布式进阶（二三）——分布式框架之可扩展：Zookeeper分布式锁
186,195,分布式进阶（二四）——分布式框架之可扩展：分布式Session
187,196,分布式进阶（二五）——分布式框架之高可用：Hystrix简介
188,197,分布式进阶（二六）——分布式框架之高可用：Hystrix资源隔离
189,198,分布式进阶（二七）——分布式框架之高可用：Hystrix请求流程
190,199,分布式进阶（二八）——分布式框架之高可用：Hystrix降级
191,200,分布式进阶（二九）——分布式框架之高可用：Hystrix熔断
192,201,分布式基础（三）——分布式理论之分布式一致性：共识问题
193,202,分布式基础（六）——分布式理论之分布式一致性：Gossip协议
194,203,分布式基础（七）——分布式理论之分布式一致性：Quorum NWR算法
195,204,分布式基础（八）——分布式理论之分布式一致性：PBFT算法
196,205,分布式基础（九）——分布式理论之分布式一致性：PoW算法
197,206,分布式基础（十）——分布式理论之分布式一致性：ZAB协议
198,207,分布式实战（一）——系统整体架构
199,208,分布式实战（二）——系统环境搭建
200,209,透彻理解设计模式系列
201,210,设计模式基础（一）——单例模式 
202,211,设计模式基础（二）——工厂模式
203,212,设计模式基础（三）——建造者模式
204,213,设计模式基础（四）——原型模式
205,214,设计模式基础（五）——代理模式
206,215,设计模式基础（六）——桥接模式
207,216,设计模式基础（七）——装饰器模式
208,217,设计模式基础（八）——适配器模式
209,218,设计模式基础（九）——门面模式
210,219,设计模式基础（十）——组合模式
211,220,设计模式基础（十一）——享元模式
212,221,设计模式基础（十二）——观察者模式
213,222,设计模式基础（十三）——模板模式
214,223,设计模式基础（十四）——策略模式
215,224,设计模式基础（十五）——职责链模式
216,225,设计模式基础（十六）——状态模式
217,226,设计模式基础（十七）——迭代器模式
218,227,设计模式基础（十八）——访问者模式
219,228,设计模式基础（十九）——备忘录模式
220,229,设计模式基础（二十）——命令模式
221,230,设计模式基础（二一）——解释器模式
222,231,设计模式基础（二二）——中介模式
223,232,分布式实战（三）——Redis持久化实战
224,233,分布式实战（四）——Redis企业级灾备方案
225,234,分布式实战（五）——Redis读写分离实战
226,235,分布式实战（六）——Redis哨兵部署实战
227,236,分布式实战（七）——Redis集群模式实战
228,237,Java多线程进阶（四五）—— J.U.C之executors框架：CompletionService实现
229,238,Java多线程进阶（四六）—— J.U.C之补遗：ThreadLocalRandom
230,239,透彻理解Spring Cloud系列（一）——Eureka介绍
231,240,透彻理解Spring Cloud系列（二）——Eureka基本使用
232,241,透彻理解Spring Cloud系列（三）——Eureka源码环境搭建
233,242,透彻理解Spring Cloud系列（四）——Eureka启动：整体流程
234,243,透彻理解Spring Cloud系列（五）——Eureka启动：配置加载
235,244,透彻理解Spring Cloud系列（六）——Eureka启动：InstanceInfo应用实例构造
236,245,透彻理解Spring Cloud系列（七）——Eureka启动：EurekaClient初始化
237,246,透彻理解Spring Cloud系列（八）——Eureka启动：PeerAwareInstanceRegistry注册表构造
238,247,透彻理解Spring Cloud系列（九）——Eureka Server：PeerEurekaNodes集群节点集合构造
239,248,透彻理解Spring Cloud系列（十）——Eureka Server：EurekaServerContext构造
240,249,透彻理解Spring Cloud系列（十一）——服务注册发现：Eureka-Client发起注册（register）
241,250,透彻理解Spring Cloud系列（十二）——服务注册发现：Eureka-Server接受注册（register）
242,251,透彻理解Spring Cloud系列（十三）——服务注册发现：全量拉取注册表及多级缓存
243,252,透彻理解Spring Cloud系列（十四）——服务注册发现：增量拉取注册表及Hash比对
244,253,透彻理解Spring Cloud系列（十五）——服务注册发现：心跳续租（renew）机制
245,254,透彻理解Spring Cloud系列（十六）——服务注册发现：服务下线（cancel）机制
246,255,透彻理解Spring Cloud系列（十七）——服务注册发现：服务剔除（eviction）机制
247,256,透彻理解Spring Cloud系列（十八）——服务注册发现：自我保护机制
248,257,透彻理解Spring Cloud系列（十九）——服务发现注册：集群同步原理
249,258,透彻理解Spring Cloud系列（二十）——Spring Cloud Eureka：注解式启动Eureka原理
250,259,透彻理解Spring Cloud系列（二一）——Ribbon基本使用
251,260,透彻理解Spring Cloud系列（二二）——Ribbon初始化流程：客户端配置原理
252,261,透彻理解Spring Cloud系列（二三）——Ribbon初始化流程：整合Eureka
253,262,透彻理解Spring Cloud系列（二四）——Ribbon工作流程：工作流程分析
254,263,透彻理解Spring Cloud系列（二五）——Ribbon工作流程：核心组件分析
255,264,透彻理解Spring Cloud系列（二六）——Feign基本使用
256,265,透彻理解Spring Cloud系列（二七）——Feign初始化流程：客户端配置原理
257,266,透彻理解Spring Cloud系列（二八）——FeignClient动态代理：创建代理对象
258,267,透彻理解Spring Cloud系列（二九）——FeignClient动态代理：请求流程
259,268,透彻理解Spring Cloud系列（三十）——Hystrix基本原理
260,269,透彻理解Spring Cloud系列（三一）——Hystrix基本使用
