
        <!DOCTYPE html><html><head><link rel="stylesheet" href="./init.css"><title> 透彻理解秒杀系统（三）——秒杀抢购服务：库存超卖</title></head>
        <body><div class="blog-info overflow-initial">
<h1 class="blog-info-title">
<strong> 透彻理解秒杀系统（三）——秒杀抢购服务：库存超卖</strong>
</h1>
<div class="blog-info-body markdown-body editor-preview-active-side">
<p>秒杀抢购服务是整个分布式秒杀系统中的一个核心服务，负责对抢购请求进行处理，包含扣减库存、下单等等，需要承载瞬间的高并发流量。</p>
<p>本章，我就对秒杀抢购服务的核心链路和整体架构进行讲解。</p>
<h2 id="-">一、业务场景</h2>
<p>我们先来看下整个秒杀抢购的业务场景，通常来说，<strong>针对某个秒杀场次，总共有多少可供秒杀的商品库存，就会通过Nginx的业务限流放进多少流量到秒杀抢购服务</strong>（当然，实际情况可能会多一些，比如一个秒杀商品的可销售库存为1000，那实际可能放进来1100）。</p>
<p>如果针对这些秒杀抢购请求，直接基于数据库行锁来做库存的扣减，那么单台16核32G的MySQL数据库，最多只能每秒抗下5000左右请求，根本满足不了秒杀这种业务场景。</p>
<p>所以说，对于秒杀抢购服务，必须要有Redis或其它NoSQL数据库来做商品库存的扣减。在秒杀开始前，就提前将每个商品的库存提前缓存到Redis中，那扣减库存其实就是针对Redis进行操作，性能可以大幅提升。</p>
<h3 id="1-1-">1.1 缓存库存</h3>
<p>既然要用Redis，那么秒杀商品的库存在什么时候缓存到Redis中去呢？当然是在秒杀场次开始前了！运营人员会通过<strong>秒杀活动管理系统</strong>配置秒杀商品的库存，一般在秒杀场次开始前1小时，就不允许再修改了。</p>
<ol>
<li>首先，运营人员通过<strong>秒杀活动管理系统</strong>配置秒杀商品的信息时，会调用商品库存服务，查询该商品的总库存，然后冻结一定的库存用于秒杀活动；</li>
<li>接着，秒杀活动管理系统将秒杀商品库存的变动发送到MQ；</li>
<li><strong>秒杀商品库存管理服务</strong>会监听MQ，当发现某个秒杀商品的库存变动后，会将新库存重新缓存到Redis集群中；</li>
<li>最后，秒杀抢购服务基于Redis直接进行库存的扣减。</li>
</ol>
<center><br/> <img src="./img/20210814152353143.png" style="zoom:120%"><br/></img></center>
<blockquote>
<p>注意：上图中我增加了一个<strong>秒杀商品库存管理服务</strong>，对于大多数小电商平台，这个服务可以和<strong>秒杀活动管理系统</strong>整合在一起，直接由<strong>秒杀活动管理系统</strong>更新Redis集群中的秒杀商品库存信息。</p>
</blockquote>
<h3 id="1-2-">1.2 库存类型</h3>
<p>在秒杀抢购服务中，商品的库存一共分为三类：</p>
<ul>
<li><strong>可销售库存：</strong>针对秒杀活动分配的商品总库存；</li>
<li><strong>锁定库存：</strong>已经秒杀抢购成功，但尚未支付成功的商品库存</li>
<li><strong>已销售库存：</strong>已完成支付的商品数量</li>
</ul>
<p>我们可以设计下面这样的Redis数据结构，来缓存秒杀商品的库存信息，基于Redis的<code>hincrby</code>、<code>hdecrby</code>等命令对库存进行操作：</p>
<pre><code class="lang-json">seckill::product::153 = {
    sale_stock_amount: 3000,
    locked_stock_amount: 0,
    saled_stock_amount: 0
}
</code></pre>
<p>秒杀抢购服务扣减商品库存的业务流程大体如下：</p>
<ol>
<li>首先，判断抢购请求对应的商品可销售库存是否足够；</li>
<li>如果不够，则直接拒绝。否则，将商品的可销售库存-1，同时锁定库存+1；</li>
<li>接着，如果用户支付成功，则将锁定库存-1，同时已销售库存+1；</li>
<li>如果用户超时未支付或支付失败，则将锁定库存-1，同时可销售库存+1。</li>
</ol>
<p>对于客户端（秒杀前端应用）来说，发送抢购请求后，其执行结果大致分为三种情况：</p>
<ol>
<li>在<strong>秒杀抢购Nginx集群</strong>这一层就被直接限流掉，对于用户来说，就是在页面上收到“抱歉，系统繁忙”的提示；</li>
<li>抢购请求进入了<strong>秒杀抢购服务</strong>，但是库存不足扣减失败，对于用户来说，就是在页面上收到“抱歉，商品已抢购一空”的提示；</li>
<li>抢购请求进入了<strong>秒杀抢购服务</strong>，并且成功扣减库存，对于用户来说，就是在页面上收到“抢购成功，正在为您生成订单，请耐心等待”，然后一段时间后跳转到订单页，要求用户进行支付。</li>
</ol>
<h2 id="-">二、库存超卖问题</h2>
<p>当我们基于Redis来做库存扣减时，首先得判断秒杀商品的可销售库存是否足够。在并发扣减库存时，必须做一些控制，否则可能出现数据混乱：比如可销售库存为1，两个抢购请求同时判断满足扣减要求，于是进行扣减，最后把可销售库存扣成了负数，这就是典型的<strong><em>库存超卖问题</em></strong>。</p>
<p>针对库存超卖问题，有一些常见的解决方案，本节我会对这些方案进行分析讲解。</p>
<h3 id="2-1-">2.1 分布式锁</h3>
<p>最常见也是最容易想到的方案当然是用<strong>分布式锁</strong>了：</p>
<ol>
<li>以秒杀商品维度加分布式锁；</li>
<li>扣减可销售库存前，抢购线程先要获取到分布式锁；</li>
<li>抢购完成或异常时，释放分布式锁。</li>
</ol>
<p>分布式锁方案的缺点也很明显，就是分布式锁的性能并不是特别好，具体的原理大家可以去看我的<a href="https://www.tpvlog.com/article/62">《分布式系统从理论到实战系列》</a>。当然，应对那种只有几百个商品的抢购分布式锁其实是足够了，如果秒杀商品的可销售总库存上万甚至数十万，就要谨慎考虑这种方案了。</p>
<h3 id="2-3-">2.3 乐观锁</h3>
<p>乐观锁方案，就是给每个秒杀商品的库存数据都绑定一个<strong>版本号</strong>，每次更新库存时都带上前一个步骤读到的版本号，版本号一致才允许修改，采用Redisson就可以实现这种分布式乐观锁。</p>
<p>但是，乐观锁方案会有很多空轮询操作，很耗费CPU（可以参见J.U.C中的很多并发同步工具类，它们都是将CAS与轮询结合使用来实现乐观锁）。</p>
<h3 id="2-4-">2.4 分段锁</h3>
<p>分段锁方案，这种方案的基本思想就是将一个秒杀商品的库存分为很多个段，每个段单独加锁并更新库存。本质就是增加锁的数量来分散热点，减少并发访问的冲突（可以参见J.U.C中的LongAdder实现）。</p>
<h3 id="2-5-lua-">2.5 Lua脚本</h3>
<p>Lua脚本方案，就是说将秒杀商品的可销售库存判断和更新库存的逻辑封装到一个Lua脚本中，一下子提交到Redis上去执行，Redis可以保证Lua脚本执行的原子性。</p>
<p><strong>Lua脚本方案是目前最常使用的方案</strong>，也是很多电商平台采用的一种方案，这种方案下，每秒上万个抢购请求过来，其实就是提交上万个Lua脚本到Redis中去执行。</p>
<blockquote>
<p>在使用Lua脚本方案时，要特别注意对于某些大库存的商品，可能为引起Redis负载不均，所以Lua脚本一般可以和分段方案结合使用，即将某个商品的库存拆分成均匀几段，分布在不同的Redis分片上。</p>
</blockquote>
<h3 id="2-6-">2.6 内存队列</h3>
<p>内存队列方案，就是对秒杀商品的一些特征值（比如商品ID）做运算，将同一个商品的抢购请求全部路由到同一个FIFO内存队列中，然后由一个消费者线程去不断轮询并处理。</p>
<p>这种方案，我在<a href="https://www.tpvlog.com/article/62">《分布式系统从理论到实战系列》</a>的实战篇中使用过，是一种可行的方案，实际落地时为了防止宕机导致内存队列中的数据丢失或者商品数量过多导致内存撑爆，一般采用分布式消息中间件（比如Kafka），我这里就不再赘述了。</p>
<h3 id="2-7-redis-">2.7 Redis内存队列</h3>
<p>Redis内存队列方案，就是说提前把秒杀商品库存（比如1万个库存），压入Redis的一个队列中去。那么，处理抢购请求的过程，就是不停的从Redis内存队列里出队元素，如果出完了，就说明该商品已经没可销售库存了。</p>
<p>Redis内存队列方案也是一种可行方案，但一般使用较少。</p>
<h2 id="-">三、下单支付</h2>
<p>秒杀抢购服务在完成库存扣减之后，就说明本次抢购是成功了，接下来就要进行下单和支付了。下单和支付的过程一般都是异步完成的，电商平台一般都有独立的支付系统和订单系统，我这里就简单介绍下后续流程，这块不是我们的秒杀系统本身的内容。</p>
<center><br/> <img src="./img/20210814152405105.png" style="zoom:120%"/><br/></center>
<ol>
<li>秒杀抢购服务发送“秒杀成功”的通知到<strong>秒杀下单服务</strong>；</li>
<li>秒杀下单服务调用<strong>订单系统</strong>接口完成下单；</li>
<li>前端页面轮询订单系统，确认本次抢购的结果，如果发现该次抢购成功生成了一笔订单，就跳转到订单页面，否则展示“抱歉，本次抢购商品已售罄”或者“抱歉，系统繁忙”之类的提示；</li>
<li>订单页面上一般会调用<strong>支付系统</strong>的接口完成支付；</li>
<li>支付成功后，订单系统会收到通知，然后更新订单状态，然后通过MQ通知到<strong>秒杀商品库存管理服务</strong>；</li>
<li>秒杀商品库存管理服务收到通知后，更新Redis集群中的秒杀商品库存信息。</li>
</ol>
<h2 id="-">四、总结</h2>
<p>本章，我对秒杀抢购服务的核心业务场景和库存超卖问题进行了分析，并给出了一系列常见的解决方案。下一章，我将对秒杀抢购的核心链路的高可用问题进行分析。</p>
</div>


<div class="article-footer overflow-initial">所属分类：<a data-original-title="点击查看分布式秒杀分类的文章" data-placement="bottom" data-toggle="tooltip" href="https://www.tpvlog.com/type/66">分布式秒杀</a></div>
</div></body>
        </html>
        