
        <!DOCTYPE html><html><head><link rel="stylesheet" href="./init.css"><title>分布式消息中间件（一）——概述</title></head>
        <body><div class="blog-info overflow-initial">
<h1 class="blog-info-title">
<strong>分布式消息中间件（一）——概述</strong>
</h1>
<div class="blog-info-body markdown-body editor-preview-active-side">
<p>本系列的第一篇，我们先来看下消息中间件能做些什么？从架构上来讲，我们之所以要在自己的系统中引入MQ，无非就是三个目的：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。本章我们会先引入一个系统示例，以此为背景，展开我们对消息中间件使用的讨论，后续我们会分章节对一些核心问题进行分析。</p>
<p>这里补充一句，在使用各种分布式技术的过程中，我们脑子里一定要有四个概念：<strong>高性能</strong>、<strong>高可用</strong>、<strong>可扩展</strong>、<strong>数据一致性</strong>。这四个概念我在<a href="https://www.tpvlog.com/article/62">《分布式系统从理论到实战系列》</a>中一直反复强调的，如果你对一些常用的分布式框架很熟悉，就会明白，无论是哪一种分布式框架，其底层所有核心功能的实现一定是围绕上述四个基本概念来展开的。</p>
<h2 id="-">一、系统背景</h2>
<p>我们先来看一下业务系统的背景，这个系统将要贯穿本系列。这是一个普通的<strong><em>订单系统</em></strong>，用户浏览商品并通过订单系统进行下单：</p>
<center><br/> <img src="./img/20200218211437124.png" style="zoom:50%"><br/></img></center>
<ol>
<li>用户下单成功并确认完订单信息后，会调用支付系统的接口进行支付；</li>
<li>支付成功后，支付系统调用订单系统接口，通知“支付成功”；</li>
<li>订单系统更新数据库中订单的状态为“支付成功”；</li>
<li>订单系统调用库存系统的接口，进行扣减库存；</li>
<li>订单系统依次调用“物流系统”、“积分系统”、“促销系统”、“通知系统”的接口，进行发货通知、增加积分、发优惠券、短信通知操作；</li>
<li>“大数据系统”会从订单数据库里查询订单数据，用于生成一些业务报表供运营使用。</li>
</ol>
<p>上述就是整个业务的主体流程，我们本章先来分析下在这样一个系统架构下，订单系统会出现哪些问题，后续章节再来看看MQ是如何解决这些问题的。</p>
<h3 id="1-1-">1.1 同步调用问题</h3>
<p>首先，最明显的，每次用户支付完一笔订单，订单系统就要同步执行一系列动作：</p>
<ol>
<li>更新订单状态</li>
<li>扣减库存</li>
<li>增加积分</li>
<li>发优惠券</li>
<li>短信通知</li>
<li>通知发货</li>
</ol>
<p>这样一连串的接口同步调用，可能长达好几秒钟，对于用户来说，其直观感受就是支付完成后界面假死，几秒之后才响应支付结果，非常不友好。</p>
<h3 id="1-2-">1.2 性能问题</h3>
<p>这样的一个系统架构，在“订单系统”水平扩展N个的情况下，虽然能扛下基本的峰值流量，但应付不了一些大型促销的业务场景（比如秒杀活动），因为瓶颈主要在数据库。我们假设正常的峰值流量是2000QPS，由于订单系统还涉及其它一些数据库访问操作，根据经验我们将数据库操作的此时放大2-3倍，也就是峰值情况下每秒大约有4000~5000的请求打到数据库：</p>
<center><br/><img src="./img/20200218211445811.png" style="zoom:55%"/><br/></center>
<p>以MySQL数据库来说，16核32G的机器，优化后大约能抗个4000~5000TPS，所以在上述峰值流量下，虽然CPU和内存使用都会飚得很高，但也差不多能应付。但是在大促场景下，峰值流量会放大好几倍，所以这种架构下，数据库是根本扛不住的。</p>
<h3 id="1-3-">1.3 耦合问题</h3>
<p>上述有一个流程是“通知发货”，物流系统一般会对接外部的第三方公司，当我们的系统对外产生依赖时，我们应该做最坏的打算，考虑依赖方的接口不可用了该怎么办？事实上，除了“扣减库存”属于核心交易链路外，其它的“通知发货”、“增加积分”、“发优惠券”、“短信通知”都属于非核心交易链路，我们应该将它们从核心链路中解耦出去。</p>
<h3 id="1-4-">1.4 大数据传输问题</h3>
<p>“大数据系统”会从订单数据库里查询订单数据，由于数据库中每日的订单数据通常是比较多的，频繁让外部系统直接通过数据库查数会影响订单系统本身的性能。试想以下，在高峰场景下，订单数据库本身去支撑正常业务流量就很吃力了，此时CPU和内存都比较吃紧，这时再来个“大数据系统”从我这里大量查数，简直是添乱。</p>
<h3 id="1-5-">1.5 状态补偿问题</h3>
<p>做过支付系统的童鞋应该都知道，对于依赖“支付通知”来确认订单状态的业务，必须要考虑“补偿”机制，也就是说：万一因为网络等原因，订单系统没收到“成功”的支付通知怎么办？除此之外，用户也很可能下完订单之后就把页面关闭掉了，最终并没有去支付。</p>
<p>所以对于这些”中间状态“的订单，我们必须要有一种补偿机制去确认它的最终状态。一种常见的思路是：订单系统后台起一个定时任务，每隔一段时间扫描下所有”中间状态“的订单，确认下是否要关闭它。但是这种方案在订单量小的情况下还好说，一旦订单量大了，就会出现性能瓶颈，而且重复扫描的效率也太低。</p>
<h2 id="-">二、技术选型</h2>
<p>了解完了业务系统的背景和存在的问题，我们就要通过MQ来解决上述的问题。那么到底使用哪种MQ呢？不着急，我们先来做下技术选型，目前常用的开源分布式消息中间件主要有四种：ActiveMQ、RabbitMQ、RocketMQ、Kafka，下表对它们进行了比较：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>万级</td>
<td>10万级</td>
<td>10万级以上</td>
</tr>
<tr>
<td>topic数量</td>
<td>/</td>
<td>/</td>
<td>topic达到千级时，吞吐量会小幅下降</td>
<td>topic达到百级时，吞吐量会大幅下降</td>
</tr>
<tr>
<td>时效性</td>
<td>毫秒级</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
</tr>
<tr>
<td>可用性</td>
<td>高，主从架构</td>
<td>高，主从架构</td>
<td>非常高，数据分散集群架构</td>
<td>极高，数据分散集群架构</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>有较低的概率丢失数据</td>
<td>经过参数配置，可以做到0丢失</td>
<td>经过参数配置，可以做到0丢失</td>
</tr>
<tr>
<td>框架开发语言</td>
<td>Java</td>
<td>erlang</td>
<td>Java</td>
<td>Java</td>
</tr>
<tr>
<td>优劣势</td>
<td>优势：非常成熟，功能完备，在业内大量的公司以及项目中都有应用；<br>劣势：社区不活跃，版本迭代很慢，不适合大规模并发场景。</br></td>
<td>优势：自带管理界面非常好用，社区活跃，版本迭代快；<br>劣势：吞吐量一般，erlang不利于研究源码。</br></td>
<td>优势：吞吐量非常高，适合大规模高并发应用，社区活跃，功能丰富；<br>劣势：依赖阿里，一旦被抛弃，后续维护有风险</br></td>
<td>优势：吞吐量极高，可用性极高，社区活跃适合大规模高并发应用，社区活跃，适合大数据实时计算以及日志收集<br>劣势：功能较单一，没RocketMQ完备</br></td>
</tr>
</tbody>
</table>
<p>订单系统对性能要求通常是比较高的，所以我们主要在RocketMQ和Kafka中选择。事实上，两种MQ都可以作为我们最后的选择，但是由于Kafka自身提供的功能较为单一，而且目前业界主要将其用在日志采集的场景上，所以本系列还是先以RocketMQ来讲解，后续有时间我们再讲解Kafka的原理。</p>
</div>


<div class="article-footer overflow-initial">所属分类：<a data-original-title="点击查看消息中间件分类的文章" data-placement="bottom" data-toggle="tooltip" href="https://www.tpvlog.com/type/33">消息中间件</a></div>
</div></body>
        </html>
        